-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParClike where
import AbsClike
import LexClike
import ErrM

}

%name pProgram Program
%name pStmt Stmt
%name pRExpr RExpr
%name pLExpr LExpr
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '#define' { PT _ (TS _ 3) }
  '%' { PT _ (TS _ 4) }
  '&' { PT _ (TS _ 5) }
  '&&' { PT _ (TS _ 6) }
  '(' { PT _ (TS _ 7) }
  ')' { PT _ (TS _ 8) }
  '*' { PT _ (TS _ 9) }
  '*=' { PT _ (TS _ 10) }
  '+' { PT _ (TS _ 11) }
  '++' { PT _ (TS _ 12) }
  '+=' { PT _ (TS _ 13) }
  ',' { PT _ (TS _ 14) }
  '-' { PT _ (TS _ 15) }
  '--' { PT _ (TS _ 16) }
  '-=' { PT _ (TS _ 17) }
  '/' { PT _ (TS _ 18) }
  '/=' { PT _ (TS _ 19) }
  ';' { PT _ (TS _ 20) }
  '<' { PT _ (TS _ 21) }
  '<=' { PT _ (TS _ 22) }
  '=' { PT _ (TS _ 23) }
  '==' { PT _ (TS _ 24) }
  '>' { PT _ (TS _ 25) }
  '>=' { PT _ (TS _ 26) }
  '[' { PT _ (TS _ 27) }
  ']' { PT _ (TS _ 28) }
  'bool' { PT _ (TS _ 29) }
  'char' { PT _ (TS _ 30) }
  'else' { PT _ (TS _ 31) }
  'false' { PT _ (TS _ 32) }
  'float' { PT _ (TS _ 33) }
  'if' { PT _ (TS _ 34) }
  'int' { PT _ (TS _ 35) }
  'string' { PT _ (TS _ 36) }
  'true' { PT _ (TS _ 37) }
  'void' { PT _ (TS _ 38) }
  'while' { PT _ (TS _ 39) }
  '{' { PT _ (TS _ 40) }
  '||' { PT _ (TS _ 41) }
  '}' { PT _ (TS _ 42) }

L_integ  { PT _ (TI $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_ident  { PT _ (TV $$) }
L_TFloat { PT _ (T_TFloat _) }
L_WriteIntPP { PT _ (T_WriteIntPP _) }
L_WriteFloatPP { PT _ (T_WriteFloatPP _) }
L_WriteCharPP { PT _ (T_WriteCharPP _) }
L_WriteStringPP { PT _ (T_WriteStringPP _) }
L_ReadIntPP { PT _ (T_ReadIntPP _) }
L_ReadFloatPP { PT _ (T_ReadFloatPP _) }
L_ReadCharPP { PT _ (T_ReadCharPP _) }
L_ReadStringPP { PT _ (T_ReadStringPP _) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
String  :: { String }  : L_quoted {  $1 }
Ident   :: { Ident }   : L_ident  { Ident $1 }
TFloat    :: { TFloat} : L_TFloat { TFloat (mkPosToken $1)}
WriteIntPP    :: { WriteIntPP} : L_WriteIntPP { WriteIntPP (mkPosToken $1)}
WriteFloatPP    :: { WriteFloatPP} : L_WriteFloatPP { WriteFloatPP (mkPosToken $1)}
WriteCharPP    :: { WriteCharPP} : L_WriteCharPP { WriteCharPP (mkPosToken $1)}
WriteStringPP    :: { WriteStringPP} : L_WriteStringPP { WriteStringPP (mkPosToken $1)}
ReadIntPP    :: { ReadIntPP} : L_ReadIntPP { ReadIntPP (mkPosToken $1)}
ReadFloatPP    :: { ReadFloatPP} : L_ReadFloatPP { ReadFloatPP (mkPosToken $1)}
ReadCharPP    :: { ReadCharPP} : L_ReadCharPP { ReadCharPP (mkPosToken $1)}
ReadStringPP    :: { ReadStringPP} : L_ReadStringPP { ReadStringPP (mkPosToken $1)}

Boolean :: { Boolean }
Boolean : 'true' { AbsClike.Boolean_true }
        | 'false' { AbsClike.Boolean_false }
RExpr :: { RExpr }
RExpr : RExpr1 { $1 } | RExpr '||' RExpr1 { AbsClike.OrOp $1 $3 $ tokenLineCol $2 }
RExpr1 :: { RExpr }
RExpr1 : RExpr2 { $1 }
       | RExpr1 '&&' RExpr2 { AbsClike.AndOp $1 $3 $ tokenLineCol $2 }
RExpr2 :: { RExpr }
RExpr2 : RExpr3 { $1 } | '!' RExpr3 { AbsClike.NotOp $2 $ tokenLineCol $1 }
RExpr3 :: { RExpr }
RExpr3 : RExpr4 { $1 }
RExpr4 :: { RExpr }
RExpr4 : RExpr5 { $1 }
RExpr5 :: { RExpr }
RExpr5 : RExpr6 { $1 }
       | RExpr6 '==' RExpr6 { AbsClike.EqOp $1 $3 $ tokenLineCol $2 }
       | RExpr6 '!=' RExpr6 { AbsClike.NeqOp $1 $3 $ tokenLineCol $2 }
       | RExpr6 '<' RExpr6 { AbsClike.LtOp $1 $3 $ tokenLineCol $2 }
       | RExpr6 '<=' RExpr6 { AbsClike.LtEOp $1 $3 $ tokenLineCol $2 }
       | RExpr6 '>' RExpr6 { AbsClike.GtOp $1 $3 $ tokenLineCol $2 }
       | RExpr6 '>=' RExpr6 { AbsClike.GtEOp $1 $3 $ tokenLineCol $2 }
RExpr6 :: { RExpr }
RExpr6 : RExpr7 { $1 }
RExpr7 :: { RExpr }
RExpr7 : RExpr8 { $1 }
       | RExpr7 '+' RExpr8 { AbsClike.AddOp $1 $3 $ tokenLineCol $2 }
       | RExpr7 '-' RExpr8 { AbsClike.SubOp $1 $3 $ tokenLineCol $2 }
RExpr8 :: { RExpr }
RExpr8 : RExpr9 { $1 }
       | RExpr8 '*' RExpr9 { AbsClike.MulOp $1 $3 $ tokenLineCol $2 }
       | RExpr8 '/' RExpr9 { AbsClike.DivOp $1 $3 $ tokenLineCol $2 }
       | RExpr8 '%' RExpr9 { AbsClike.ModOp $1 $3 $ tokenLineCol $2 }
RExpr9 :: { RExpr }
RExpr9 : RExpr10 { $1 }
RExpr10 :: { RExpr }
RExpr10 : RExpr11 { $1 }
RExpr11 :: { RExpr }
RExpr11 : RExpr12 { $1 }
        | '-' RExpr12 { AbsClike.NegOp $2 $ tokenLineCol $1 }
        | '&' LExpr { AbsClike.RefOp $2 $ tokenLineCol $1 }
RExpr12 :: { RExpr }
RExpr12 : RExpr13 { $1 } | FunCall { AbsClike.FCall $1 }
RExpr13 :: { RExpr }
RExpr13 : RExpr14 { $1 }
        | Integer { AbsClike.Int $1 }
        | Char { AbsClike.Char $1 }
        | String { AbsClike.String $1 }
        | TFloat { AbsClike.Real $1 }
        | Boolean { AbsClike.Bool $1 }
RExpr14 :: { RExpr }
RExpr14 : '(' RExpr ')' { $2 } | LExpr { AbsClike.Lexpr $1 }
FunCall :: { FunCall }
FunCall : Ident '(' ListRExpr ')' { AbsClike.Call $1 $3 $ tokenLineCol $2 }
        | WriteIntPP '(' RExpr ')' { AbsClike.WIntCall $1 $3 }
        | WriteFloatPP '(' RExpr ')' { AbsClike.WFloatCall $1 $3 }
        | WriteCharPP '(' RExpr ')' { AbsClike.WCharCall $1 $3 }
        | WriteStringPP '(' RExpr ')' { AbsClike.WStringCall $1 $3 }
        | ReadIntPP '(' ')' { AbsClike.RIntCall $1 }
        | ReadFloatPP '(' ')' { AbsClike.RFloatCall $1 }
        | ReadCharPP '(' ')' { AbsClike.RCharCall $1 }
        | ReadStringPP '(' ')' { AbsClike.RStringCall $1 }
ListRExpr :: { [RExpr] }
ListRExpr : {- empty -} { [] }
          | RExpr { (:[]) $1 }
          | RExpr ',' ListRExpr { (:) $1 $3 }
LExpr :: { LExpr }
LExpr : LExpr1 { $1 }
      | '++' LExpr1 { AbsClike.PreInc $2 $ tokenLineCol $1 }
      | '--' LExpr1 { AbsClike.PreDecr $2 $ tokenLineCol $1 }
LExpr1 :: { LExpr }
LExpr1 : LExpr2 { $1 }
       | LExpr2 '++' { AbsClike.PostInc $1 $ tokenLineCol $2 }
       | LExpr2 '--' { AbsClike.PostDecr $1 $ tokenLineCol $2 }
LExpr2 :: { LExpr }
LExpr2 : '(' LExpr ')' { $2 } | BLExpr { AbsClike.BasLExpr $1 }
BLExpr :: { BLExpr }
BLExpr : BLExpr '[' RExpr ']' { AbsClike.ArrayEl $1 $3 $ tokenLineCol $2 }
       | Ident { AbsClike.Id $1 }
       | '*' BLExpr { AbsClike.Deref $2 $ tokenLineCol $1 }
Program :: { Program }
Program : ListConstanct ListDeclar { AbsClike.Progr (reverse $1) (reverse $2) }
ListDeclar :: { [Declar] }
ListDeclar : {- empty -} { [] }
           | ListDeclar Declar { flip (:) $1 $2 }
Declar :: { Declar }
Declar : Type ListMoreVar ';' { AbsClike.VarDecl $1 $2 $ tokenLineCol $3 }
       | 'void' Ident '(' ListParameter ')' ';' { AbsClike.FunDecl $2 $4 $ tokenLineCol $1 }
       | 'void' Ident '(' ListParameter ')' BlockStmt { AbsClike.ProcDecl $2 $4 $6 $ tokenLineCol $1 }
MoreVar :: { MoreVar }
MoreVar : Ident Init { AbsClike.VarInit $1 $2 }
Init :: { Init }
Init : {- empty -} { AbsClike.Init1 }
     | '=' ComplexRExpr { AbsClike.Init2 $2 }
Constanct :: { Constanct }
Constanct : '#define' Ident Type RExpr13 { AbsClike.Const $2 $3 $4 $ tokenLineCol $1 }
ListConstanct :: { [Constanct] }
ListConstanct : {- empty -} { [] }
              | ListConstanct Constanct { flip (:) $1 $2 }
ListMoreVar :: { [MoreVar] }
ListMoreVar : MoreVar { (:[]) $1 }
            | MoreVar ',' ListMoreVar { (:) $1 $3 }
ComplexRExpr :: { ComplexRExpr }
ComplexRExpr : RExpr { AbsClike.Simple $1 }
             | '[' ListComplexRExpr ']' { AbsClike.Array $2 }
ListComplexRExpr :: { [ComplexRExpr] }
ListComplexRExpr : ComplexRExpr { (:[]) $1 }
                 | ComplexRExpr ',' ListComplexRExpr { (:) $1 $3 }
Type :: { Type }
Type : BasicType { AbsClike.BasType $1 }
     | CompositeType { AbsClike.CompType $1 }
BasicType :: { BasicType }
BasicType : 'bool' { AbsClike.BasicType_bool }
          | 'char' { AbsClike.BasicType_char }
          | 'float' { AbsClike.BasicType_float }
          | 'int' { AbsClike.BasicType_int }
          | 'string' { AbsClike.BasicType_string }
          | 'void' { AbsClike.BasicType_void }
CompositeType :: { CompositeType }
CompositeType : Type '[' RExpr ']' { AbsClike.ArrDef $1 $3 }
              | Type '[' ']' { AbsClike.ArrNoDef $1 }
              | Type '*' { AbsClike.Pointer $1 }
ListParameter :: { [Parameter] }
ListParameter : {- empty -} { [] }
              | Parameter { (:[]) $1 }
              | Parameter ',' ListParameter { (:) $1 $3 }
Parameter :: { Parameter }
Parameter : Type Ident { AbsClike.Param $1 $2 }
BlockStmt :: { BlockStmt }
BlockStmt : '{' ListDeclar ListStmt '}' { AbsClike.ProcBlock (reverse $2) (reverse $3) }
ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } | ListStmt Stmt { flip (:) $1 $2 }
Stmt :: { Stmt }
Stmt : Declar { AbsClike.MoreDecl $1 }
     | FunCall ';' { AbsClike.ProcCall $1 }
     | WhileStmt { AbsClike.IndIter $1 }
     | ConditionStmt { AbsClike.Cond $1 }
     | BLExpr Assignment_op RExpr ';' { AbsClike.Assgn $1 $2 $3 $ tokenLineCol $4 }
     | LExpr ';' { AbsClike.LExprStmt $1 }
Assignment_op :: { Assignment_op }
Assignment_op : '=' { AbsClike.Assign }
              | '*=' { AbsClike.AssgnMul }
              | '+=' { AbsClike.AssgnAdd }
              | '/=' { AbsClike.AssgnDiv }
              | '-=' { AbsClike.AssgnSub }
ConditionStmt :: { ConditionStmt }
ConditionStmt : 'if' '(' RExpr ')' BlockStmt { AbsClike.IfNoElse $3 $5 $ tokenLineCol $1 }
              | 'if' '(' RExpr ')' BlockStmt 'else' BlockStmt { AbsClike.IfYesElse $3 $5 $7 $ tokenLineCol $1 }
WhileStmt :: { WhileStmt }
WhileStmt : 'while' '(' RExpr ')' BlockStmt { AbsClike.While $3 $5 $ tokenLineCol $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

