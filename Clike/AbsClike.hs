

module AbsClike where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
newtype TFloat = TFloat ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
newtype WriteIntPP = WriteIntPP ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
newtype WriteFloatPP = WriteFloatPP ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
newtype WriteCharPP = WriteCharPP ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
newtype WriteStringPP = WriteStringPP ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
newtype ReadIntPP = ReadIntPP ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
newtype ReadFloatPP = ReadFloatPP ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
newtype ReadCharPP = ReadCharPP ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
newtype ReadStringPP = ReadStringPP ((Int,Int),String)
  deriving (Eq, Ord, Show, Read)
data Boolean = Boolean_true | Boolean_false
  deriving (Eq, Ord, Show, Read)

data RExpr
    = OrOp RExpr RExpr (Int,Int) 
    | AndOp RExpr RExpr (Int,Int) 
    | NotOp RExpr (Int,Int) 
    | EqOp RExpr RExpr (Int,Int) 
    | NeqOp RExpr RExpr (Int,Int) 
    | LtOp RExpr RExpr (Int,Int) 
    | LtEOp RExpr RExpr (Int,Int) 
    | GtOp RExpr RExpr (Int,Int) 
    | GtEOp RExpr RExpr (Int,Int) 
    | AddOp RExpr RExpr (Int,Int) 
    | SubOp RExpr RExpr (Int,Int) 
    | MulOp RExpr RExpr (Int,Int) 
    | DivOp RExpr RExpr (Int,Int) 
    | ModOp RExpr RExpr (Int,Int) 
    | NegOp RExpr (Int,Int) 
    | RefOp LExpr (Int,Int) 
    | FCall FunCall
    | Int Integer
    | Char Char
    | String String
    | Real TFloat
    | Bool Boolean
    | Lexpr LExpr
  deriving (Eq, Ord, Show, Read)

data FunCall
    = Call Ident [RExpr] (Int,Int) 
    | WIntCall WriteIntPP RExpr
    | WFloatCall WriteFloatPP RExpr
    | WCharCall WriteCharPP RExpr
    | WStringCall WriteStringPP RExpr
    | RIntCall ReadIntPP
    | RFloatCall ReadFloatPP
    | RCharCall ReadCharPP
    | RStringCall ReadStringPP
  deriving (Eq, Ord, Show, Read)

data LExpr
    = PreInc LExpr (Int,Int) 
    | PreDecr LExpr (Int,Int) 
    | PostInc LExpr (Int,Int) 
    | PostDecr LExpr (Int,Int) 
    | BasLExpr BLExpr
  deriving (Eq, Ord, Show, Read)

data BLExpr = ArrayEl BLExpr RExpr (Int,Int)  | Id Ident | Deref BLExpr (Int,Int) 
  deriving (Eq, Ord, Show, Read)

data Program = Progr [Constanct] [Declar]
  deriving (Eq, Ord, Show, Read)

data Declar
    = VarDecl Type [MoreVar] (Int,Int) 
    | FunDecl Ident [Parameter] (Int,Int) 
    | ProcDecl Ident [Parameter] BlockStmt (Int,Int) 
  deriving (Eq, Ord, Show, Read)

data MoreVar = VarInit Ident Init
  deriving (Eq, Ord, Show, Read)

data Init = Init1 | Init2 ComplexRExpr
  deriving (Eq, Ord, Show, Read)

data Constanct = Const Ident Type RExpr (Int,Int)
  deriving (Eq, Ord, Show, Read)

data ComplexRExpr = Simple RExpr | Array [ComplexRExpr]
  deriving (Eq, Ord, Show, Read)

data Type = BasType BasicType | CompType CompositeType
  deriving (Eq, Ord, Show, Read)

data BasicType
    = BasicType_bool
    | BasicType_char
    | BasicType_float
    | BasicType_int
    | BasicType_string
    | BasicType_void
  deriving (Eq, Ord, Show, Read)

data CompositeType
    = ArrDef Type RExpr | ArrNoDef Type | Pointer Type
  deriving (Eq, Ord, Show, Read)

data Parameter = Param Type Ident
  deriving (Eq, Ord, Show, Read)

data BlockStmt = ProcBlock [Declar] [Stmt]
  deriving (Eq, Ord, Show, Read)

data Stmt
    = MoreDecl Declar
    | ProcCall FunCall
    | IndIter WhileStmt
    | Cond ConditionStmt
    | Assgn BLExpr Assignment_op RExpr (Int,Int) 
    | LExprStmt LExpr
  deriving (Eq, Ord, Show, Read)

data Assignment_op
    = Assign | AssgnMul | AssgnAdd | AssgnDiv | AssgnSub
  deriving (Eq, Ord, Show, Read)

data ConditionStmt
    = IfNoElse RExpr BlockStmt (Int,Int) | IfYesElse RExpr BlockStmt BlockStmt (Int,Int)
  deriving (Eq, Ord, Show, Read)

data WhileStmt = While RExpr BlockStmt (Int,Int)
  deriving (Eq, Ord, Show, Read)

